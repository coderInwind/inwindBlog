---
  title: 使用WebScoket实现聊天室
  date: 2023-10-22T11:43:04Z
  summary:
  tags: []
---
  
  ### 前言
下来一个需求，要求实现类型一个聊天室的功能，我们使用到了`websocket`进行双向通讯实现。
* 什么是websocket
mdn做出如下解释：[WebSockets](https://developer.mozilla.org/zh-CN/docs/Web/API/WebSocket) 是一种先进的技术。它可以在用户的浏览器和服务器之间打开交互式通信会话。使用此 API，你可以向服务器发送消息并接收事件驱动的响应，而无需通过轮询服务器的方式以获得响应。
websocket与http协议相同点是他们都是基于TCP的协议，不同的是有以下几点：
* websocket和http的区别
1. websocket是双向通信协议，而http是单向的
2. 在建立连接的过程中，websocket会利用http请求进行握手，会经历四步: 客户端发送握手请 --> 服务端响应握手请求--> 客户端验证请求 --> 建立连接。而http需要经历三握四挥。

### websocket 实现聊天室

首先我们需要建立websocket连接，值得注意的是如果你想在请求头上携带token，websocket是不支持自定义请求头名的，你可以放到第二个参数里，后端通过请求头`sec-websocket-protocol`获取，或者你可以直接凭借到请求的url上：
```
 chatState.chatInstance = new WebSocket(
    import.meta.env.VITE_WS_CHAT_URL + token
  );
 chatState.chatInstance.onopen = (res) => {
    console.log("实例化成功", res);
    // 开启心跳
    chatState.chatInstance.send(JSON.stringify({ msg: "[PING]" }));
 };
// 监听接收的信息
chatState.chatInstance.onmessage = (res) => {
 ...
})
```
这样就完成了一个简单的websocket连接。

### 心跳
websocket并在不收发信息的情况下并不能一直维持连接，所以我们需要做心跳来维持websocket的连接，心跳这个名字我觉得形容的很恰当，心不跳自然就断开了，做心跳要和服务端约定好，我这里传一个`[PING]`，服务端就会返回一个`[PONG]`，我们在收到服务器消息的时候写一个定时器，过30s后我们再次发送，这样就能通过心跳维持WS的连接了。

### 聊天信息的流式输出
因为在聊天的时候可能出现一些长文本，为了优化用户体验，我们需要实现一个流式输出的功能，我跟后端约定聊天的回复会一个字或几个字的传回来，但他们前后必须是有`[BEGIN]`和`[DONE]`消息的，所以在接收到相关的消息是我们将字符一个个拼接起来就能实现流式效果了。

### 语音的流式播放
同样的，长文本的语音播放太慢了，所以实现了一个语音的流式播放（真折磨）,这里我同样使用到了websocket，后端将TTS合成的二进制数据，然后一段段的传回来，这里我用到了一个库`pcm-player`：
```
const initPlayer = (index) => {
  ttsState.audioInstance[index] = new PCMPlayer({
    encoding: "16bitInt", //编码 可能的值 8bitInt / 16bitInt / 32bitInt / 32bitFloat 默认值：16bitInt
    channels: 1, // PCM 数据中的通道数
    sampleRate: 16000, // PCM 数据的采样率
    flushTime: 2000, //  以毫秒为单位播放的 PCM 数据的刷新间隔。默认 1000ms
    onended: onPlayerEnd,
  });
};



chatState.ttsInstance.onmessage = async (res) => {
      // 转化数据格式
      const arrayBuffer = await res.data.arrayBuffer();
      const newUint8Array = new Uint8Array(arrayBuffer);
      ttsState.audioInstance[ttsState.isActiveIndex].feed(newUint8Array);
    
};
```
我们把接收到的一段段`Blob`数据传给player实例的feed方法，但需要注意的是只接收`TypedArray`类型或`ArrayBuffer`类型，等待缓冲完毕之后音频就会播放出来了，这些属性类型有些同学可能会觉得陌生，他们都是是处理二进制数据必不可少了，在下篇文章我会将使用到的二进制对象和他们直接如何转化的相关内容整理到一起。

等你实现了功能后，你就会发现，坑爹的包连个播放开始钩子都没有，播放结束钩子`onended`也不准，播放长语音的时候播放到中通就调用了。看来想偷懒少读代码也是件难事，我们展开看看这个包，写的挺好的就是封装的比较简洁，作者也应该没有再维护了，但我还是去提了个issues：
![image](https://github.com/coderInwind/inwindBlog/assets/91716457/22ce07bb-52d9-44ab-a243-7fdddb2d1737)

那么只能自己动手了，首先我们分析一下它的源码：







  